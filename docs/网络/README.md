---
title:网络
---

## **网络基础**

[网络协议——七层、五层、四层协议概念及功能分析](https://blog.csdn.net/buknow/article/details/81148684)

### OSI 七层模型

1. 应用层

   为应用程序提供服务，并管理应用程序之间的通信。

   协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP

2. 表示层

   处理数据的标识问题，比如编码、格式转化、加密解密等

   格式有，JPEG、ASCll、DECOIC、加密格式等

3. 会话层

   负责建立管理和断开通信连接，实现数据同步

4. 传输层

   端到端传输数据，同时处理传输错误、控制流量等

   协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层

5. 网络层

   地址管理、路由选择

   协议有：ICMP IGMP IP（IPV4 IPV6）

6. 数据链路层

   数据分割成帧，mac 寻址、差错校验、信息纠正等(以太网)

7. 物理层

   利用传输介质为数据链路层提供物理连接

![](/assets/img/七层模型.jpg)

### URI URL URN

URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。
它并不是我们常说的网址, 网址指的是 URL, 实际上 URI 包含了 URN 和 URL 两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。

URI 的结构

![](/assets/img/URI.png)

scheme 表示协议名，比如 http, https, file 等等。后面必须和://连在一起
user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用

host:port 表示主机名和端口

path 表示请求路径，标记资源所在位置

query 表示查询参数，为 key=val 这种形式，多个键值对之间用&隔开

fragment 表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置

```
https://www.baidu.com/s?wd=HTTP&rsv_spt=1
```

复制代码这个 URI 中，https 即 scheme 部分，www.baidu.com 为 host:port 部分（注意，http 和 https 的默认端口分别为 80、443），/s 为 path 部分，而 wd=HTTP&rsv_spt=1 就是 query 部分

URI 编码
URI 只能使用 ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。
因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。

### CDN

CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的
功能。

用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CDN 服务器将请求定位到最近的含有该资源的服务器上去请求。

1. 有利于提高网站的访问速度
2. 减轻了源服务器的访问压力

[CDN 是什么？使用 CDN 有什么优势](https://www.zhihu.com/question/36514327?rf=37353035)

## **HTTP**

### HTTP 请求方法

GET: 通常用来获取资源

HEAD: 只请求资源的头部，该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源

POST: 提交数据，即上传数据

PUT: 修改数据，若资源不存在则新建一个

DELETE: 删除资源(几乎用不到)

CONNECT: 建立连接隧道，用于代理服务器

OPTIONS: 列出可对资源实行的请求方法，用来跨域请求，CORS 的请求预检

TRACE: 追踪请求-响应的传输路径

[HTTP 请求方法](https://developer.mozilla.org/zh-cn/docs/web/http/methods)

#### POST GET

1. 缓存，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会
   - get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post 不同，post 做的一般是修改和删除数据的工作，所以必须与数据库交互，所以不能使用缓存。
2. 编码，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制
3. 参数，GET 一般放在 URL 中，有长度限制且不安全，POST 放在请求体中，更适合传输敏感信息
4. 幂等性，GET 是幂等的，而 POST 不是
5. 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

#### PUT 和 POST

如果一个运算重复执行多次，产生的效果是一样的，那就是幂等。

PUT 请求：幂等，即重复操作不会产生变化，10 次 PUT 的创建请求与 1 次 PUT 的创建请求相同（所以 PUT 用来改资源）

POST 请求：不幂等的，后一个请求不会把第一个请求覆盖掉。10 次 POST 请求将会创建 10 个资源。（所以 Post 用来增资源）

PUT 指定了资源在服务器上的位置，POST 没有

### HTTP 协议的特点

- 无连接
  - 限制每次连接只处理一个请求
- 无状态
  - 协议对于事务处理没有记忆能力。
- 简单快速
  - 客户向服务器请求服务时，只需传送请求方法和路径。
- 灵活
  - HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

### 状态码

[HTTP 响应代码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)

#### 1XX 信息响应状态码

表示目前是协议处理的中间状态，还需要后续操作

- **100** Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息
- **101** Switching Protocols。在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101

#### 2XX 成功响应状态码

表示成功状态

- **200** OK 正常返回信息
- **201** Created 请求成功并且服务器创建了新的资源
- **202** Accepted 服务器已接受请求，但尚未处理
- **204** No content，表示请求成功，但响应报文不含实体的主体部分
- **205** Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
- **206** Partial Content，进行范围请求，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 `Content-Range`

#### 3XX 重定向

重定向状态，资源位置发生变动，需要重新请求

- **301** Moved Permanently 永久性重定向，表示资源已被分配了新的 URL
- **302** Found 临时性重定向，表示资源临时被分配了新的 URL

网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。如果只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。

- **303** See Other 表示资源存在着另一个 URL，应使用 GET 方法获取资源
- **304** Not Modify 未修改，当协商缓存命中时会返回
- **307** 临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

#### 4XX 客户端错误

请求报文有误

- **400** Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求
- **401** Unauthorized 请求未授权
- **403** forbidden 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感
- **404** Not Found 在服务器上没有找到请求的资源
- **405** Method Not Allowed: 请求方法不被服务器端允许。
- **406** Not Acceptable: 资源无法满足客户端的条件。
- **408** Request Timeout: 服务器等待了太长时间。
- **409** Conflict: 多个请求发生了冲突。
- **413** Request Entity Too Large: 请求体的数据过大。
- **414** Request-URI Too Long: 请求行里的 URI 太大。
- **429** Too Many Request: 客户端发送的请求过多。
- **431** Request Header Fields Too Large 请求头的字段内容太大。

#### 5XX 服务器错误

服务器端发生错误

- **500** Internal Server Error:仅仅告诉你服务器出错了
- **501** Not Implemented:表示服务器不支持当前请求所需要的某个功能
- **502** Bad Gateway:服务器自身是正常的，但访问的时候出错了，
- **503** Service Unavailable:表明服务器暂时处于超负载或正在停机维护，无法处理请求

### HTTP 头部

[HTTP Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)

#### 请求头部

```
cookie: ''
host: ''
If-None-Match: ''
If-Modified-Since: ''
```

##### host 与 虚拟主机

host 字段是 HTTP1.1 新增的头部，主要用来实现虚拟主机

一台物理主机上当然可以在不同端口上部署多个服务端。一台主机也可以给多个不同的域名以供访问。

那么可以通过 nginx 来实现虚拟主机，配置类似如下。

```
server
{
  listen 80
  server_name www.aaa.com;
  ## 可以在这进行代理
  location / {
    proxy_pass localhost:3000
  }
}
server
{
  listen 80
  server_name www.bbb.com;
  location / {
    proxy_pass localhost:8080
  }
}
```

无论是 www.aaa.com 还是 www.bbb.com，都能访问我们的服务器。

根据域名/host 的不同，代理向不同的服务端。

#### 响应头部

Set-Cookie: ''
Location: '/'
ETag: ''
Last-Modified: ''
Cache-Control: 'max-age='
expires: ''
access-control-allow-origin: '\*'
access-control-allow-credentials: true ##通用头部
accept: ''
accept-language: ''
content-Type: ''
content-length: ''

#### 通用头部

```
accept: ''
accept-language: ''
content-Type: ''
content-length: ''
```

### 请求报文

```js
GET /home HTTP/1.1
```

- 请求行
  - 请求方法
  - 请求 URL
  - HTTP 协议版本号
- 请求头
  - 用来说明一些附加信息
- 空行
  - 用来区分开头部和实体
- 请求体
  - 可以添加任意的其他数据

### 响应报文

```js
HTTP/1.1 200 OK
```

- 状态行
  - HTTP 协议版本号
  - 状态码
  - 状态消息
- 响应头
  - 说明客户端要使用的一些附加信息
- 空行
  - 用来区分开头部和实体
- 响应体
  - 返回给客户端的文本信息

### HTTP1.1

1.  连接方面的区别

    http1.1 默认使用长连接
    http1.0 默认使用短连接。
    http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延

2.  资源请求方面的区别

    在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个
    对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码
    是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

3.  缓存方面的区别

    在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1
    则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来
    控制缓存策略。

4.  http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，
    请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机
    ，并且它们共享一个 IP 地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。

5.  http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。

#### HTTP1.1 长连接

HTTP 协议采用“请求-应答”模式，并且 HTTP 是基于 TCP 进行连接的。普通模式（非 keep-alive）时，每个请求或应答都需要建立一个连接，完成之后立即断开。

当使用`Conection: keep-alive`模式（又称持久连接、连接重用）时，keep-alive 使客户端道服务器端连接持续有效，即不关闭底层的 TCP 连接，当出现对服务器的后继请求时，keep-alive 功能避免重新建立连接。

`Keep-Alive: timeout=5, max=1000`

`timeout`：指定了一个空闲连接需要保持打开状态的最小时长（以秒为单位）

`max`：在连接关闭之前，在此连接可以发送的请求的最大值。

#### HTTP1.1 管线化

![pipe](/assets/img/pipe.png)

管线化后，请求和响应不再是依次交替的了。他可以支持一次性发送多个请求，并一次性接收多个响应。

- 只有 GET 与 head 请求可以进行管线化，POST 有限制
- 初次创建连接时不应该启动管线机制，因为服务器不一定支持该协议

### HTTP 数据协商

在客户端向服务端发送请求的时候，客户端会申明可以接受的数据格式和数据相关的一些限制是什么样的；服务端在接受到这个请求时他会根据这个信息进行判断到底返回怎样的数据。

#### 请求

- Accept
  - 在请求中使用 Accept 可申明想要的数据格式
- Accept-Encoding
  - 告诉服务端使用什么的方式来进行压缩
  - 例如：gzip、deflate、br
- Accept-Language
  - 描述语言信息
- User-Agent
  - 用来描述客户端浏览器相关信息
  - 可以用来区分 PC 端页面和移动端页面

#### 响应

- Content-Type
  - 对应 Accept，从请求中的 Accept 支持的数据格式中选一种来返回
- Content-Encoding
  - 对应 Accept-Encoding，指服务端到底使用的是那种压缩方式
- Content-Language
  - 对应 Accept-Language

#### form 表单中 enctype 数据类型

- `application/x-www-form-urlencoded`
  - key=value&key=value 格式
- `multipart/form-data`
  - 用于提交文件
  - multipart 表示请求是由多个部分组成（因为上传文件的时候文件不能以字符串形式提交，需要单独分出来）
  - boundary 用来分隔不同部分
- `text/plain`

### RESTful

[理解 RESTful 架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)

RESTful 架构：

（1）每一个 URI 代表一种资源,所以网址中不能有动词，只能有名词。

（2）客户端和服务器之间，传递这种资源的某种表现层；

（3）客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现"表现层状态转化"。

## **HTTP 2.0**

[**HTTP1.0、HTTP1.1 和 HTTP2.0 的区别**](https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A)

由于 HTTPS 在安全方面已经做的非常好了，HTTP2.0 改进的关注点放在了性能方面

### 头部压缩

在 HTTP 1.X 中，使用文本的形式传输头部，在头部携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP 2.0 中，对报文的头部进行压缩，在客户端和服务端都维护着一份字典记录着头部对应的索引

在 HTTP/1.1 及之前的时代，请求体一般会有响应的压缩编码过程，通过`Content-Encoding`头部字段来指定，但当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。

HPACK 算法是专门为 HTTP/2 服务的，它主要的亮点有两个：

- 首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如 0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用。

![](/assets/img/头部压缩.png)

HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个":"前缀，用来和其它请求头区分开。

- 其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率。

### 多路复用

HTTP/2 从 HTTP 协议本身解决了队头阻塞问题。注意，这里并不是指的 TCP 队头阻塞，而是 HTTP 队头阻塞，两者并不是一回事。TCP 的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而 HTTP 的队头阻塞是在 HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。

在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

![](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-042650.png)

### 二进制传输

HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

- http1.1 头信息必须是字符，数据体可以是文本，也可以是二进制
- http2 全部是二进制

![](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-042649.png)

### 服务端推送

在 HTTP 2.0 中，服务端可以预测客户端需要的资源，并主动推送给客户端

HTTP1.1 解析 HTML 里面 CSS、JS 文件，需要解析到 CSS 和 JS 文件发送请求，等数据回来渲染

HTTP2 解析 HTML 里面建立连接，如果有 CSS、JS 文件，服务端会主动推送到客户端，不在发送请求获取 CSS、JS 文件

## **HTTPS**

[SSL/TLS 协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

[HTTPS 原理及流程](https://www.jianshu.com/p/14cd2c9d2cd2)

[看完这篇 HTTPS，和面试官扯皮就没问题了](https://blog.csdn.net/qq_36894974/article/details/104856083?utm_source=app)

### HTTPS 和 HTTP 区别

1. HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头

2. HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443

3. HTTP 是不安全的 信息是明文传输，而 HTTPS 是安全的具有安全性的 ssl 加密传输

4. HTTP 无需证书，而 HTTPS 需要认证证书

### 防止中间人攻击

服务器向客户端发送公钥。
攻击者截获公钥，保留在自己手上。
然后攻击者自己生成一个【伪造的】公钥，发给客户端。
客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
同时生成假的加密 hash 值，发给服务器。
服务器用私钥解密获得假秘钥。

这里就需要一个强大的公证人，就是 CA，操作系统会做 CA 证书的判断。

[HTTPS 的数字证书验证原理](https://blog.csdn.net/liuxingrong666/article/details/83869161?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)

## **DNS**

DNS 查询过程

1. 浏览器是否有缓存
2. 操作系统是否有缓存
3. 本地 Hosts 文件是否有缓存
4. 本地 DNS 服务器是否有缓存
5. 向根域名 DNS 服务器查询，若知道对应 IP 则返回 IP，不知道则告诉本地 DNS 服务器要去哪个顶级域名服务器查询
6. 迭代，直到找到对应的 ip

递归

本地 <=> 本地 DNS 服务器 <=> 权威 DNS 服务器

迭代

本地 DNS 服务器 <=> 根域名服务器，若查不到则进行下一步

​ <=> 顶级域名服务器，若查不到则进行下一步

​ <=> 二级域名服务器...

解析记录

A 记录，解析域名到 IP
CNAME 记录，解析域名到域名
其他各种记录

## **TCP**

[TCP 的三次握手与四次挥手理解及面试题](https://blog.csdn.net/qq_38950316/article/details/81087809)
[http 三次握手四次挥手](https://www.cnblogs.com/nevermorewang/p/8906833.html)

### TCP 保证可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. 超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
3. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
4. 校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
5. TCP 的接收端会丢弃重复的数据。
6. 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。
7. 拥塞控制：当网络拥塞时，减少数据的发送。

### TCP 头部

![TCP header](/assets/img/TCP.png)

对于 TCP 头部来说，以下几个字段是很重要的:

- `序列号` （Sequence number），这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文

- `确认号` （Acknowledgement Number），这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到

- `窗口大小` （Window Size），表示还能接收多少字节的数据，用于流量控制

- `标识符`
  - ACK=1 ：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK=1。
  - SYN=1：当 SYN=1，ACK=0 时，表示当前报文段是一个连接请求报文。当 SYN=1，ACK=1 时，表示当前报文段是一个同意建立连接的应答报文。
  - FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。
  - URG=1 : 该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
  - PSH=1 ：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
  - RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。

### 三次握手

刚开始客户端处于 closed 状态，服务端处于 listen 状态。然后

Client 给 Server 发送报文，Server 知道自己能接收到 Client 发送的报文

该报文的 SYN = 1， seq = x

Server 给 Client 发送报文，Client 知道自己能接收 Server 发送的报文，知道自己发送的报文能被 Server 接收

该报文的 SYN = 1, ACK = 1，ack = x + 1， seq = y

Client 给 Server 发送报文，Server 知道自己发送的报文能被 Client 接收。

该报文的 ACK = 1 ,ack = y + 1

经过三次握手，客户端（Client）和服务端（Server）都知道自己发送的报文能被对方接收，也知道自己能接收到对方的报文。

### 两次握手

防止已经失效的连接请求报文段被服务端接收的情况，从而产生错误。

客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。

假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接

### 四次挥手

![四次挥手](/assets/img/quarticBye.png)

刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

1. 第一次挥手：客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求

2. 第二次握手：B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A

3. 第三次挥手：B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态

4. 第四次挥手：A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态

由于在客户端要关闭 TCP 连接的时候，服务端可能还在发送数据；所以服务端先进行第二次挥手，这个报文的作用是服务端不再接收数据；当服务端的数据全部发送过去后，再一次挥手，这样服务端就不再发送数据了；至此，TCP 连接就关闭了

### A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态

为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。

### 建立连接是三次握手，关闭连接确是四次挥手

建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。

而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了

### ARQ （超时重传）协议

通过确认和超时机制保证了数据的正确送达，ARQ 协议包含`停止等待 ARQ` 和`连续 ARQ`

#### 停止等待 ARQ

**正常传输过程**

只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。

**当报文丢失或出错：**

报文传输的过程中丢包： 这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。

传输过程中报文出错： 对端会抛弃该报文并等待 A 端重传。

PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。

**ACK 超时或丢失：**

对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。

这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。

#### 连续 ARQ

在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。

##### 累计确认

连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1 的数据。

但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决。

##### 滑动窗口

上面讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。

发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。

![滑动窗口](/assets/img/slideWindow.png)

发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。

当发送端接收到应答报文后，会随之将窗口进行滑动

**滑动窗口实现了流量控制**。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。

**Zero 窗口**

在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。

### 拥塞控制

拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。

拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。

#### 慢开始算法

慢开始算法，顾名思义，就是在传输开始时将发送窗口从 1 开始指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。

慢开始算法步骤具体如下

1. 连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）
2. 每过一个 RTT (往返时延) 就将窗口大小乘二
3. 指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法

#### 拥塞避免算法

拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。

在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：

- 将阈值设为当前拥塞窗口的一半
- 将拥塞窗口设为 1 MSS
- 启动拥塞避免算法

#### 快速重传

快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：

#### RTT 与 RTO

- **RTT**(Round Trip Time)
  - 一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值。
- **RTO**(Retransmission Time Out)
  - 重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。
- RTT 和 RTO 的关系是
  - 由于网络波动的不确定性，每个 RTT 都是动态变化的，所以 RTO 也应随着 RTT 动态变化。

[博客链接](https://blog.csdn.net/whgtheone/article/details/80970292)

#### TCP 小结

为什么 TCP 这么复杂?

因为既要保证可靠性, 同时又要尽可能提高性能

保证可靠性的机制

- 校验和
- 序列号(按序到达)
- 确认应答
- 超时重传
- 连接管理
- 流量控制
- 拥塞控制

提高性能的机制

- 滑动窗口
- 快速重传
- 延迟应答
- 捎带应答

定时器

- 超时重传定时器
- 保活定时器
- TIME_WAIT 定时器

#### 基于 TCP 的应用层协议

- HTTP
- HTTPS
- SSH
- Telnet
- FTP
- SMTP

## **UDP**

|                    UDP                     |                                    TCP                                     |
| :----------------------------------------: | :------------------------------------------------------------------------: |
|                   无连接                   |                    面向连接(间传输数据之前要先建立连接)                    |
| 支持一对多、多对一、一对一、多对多交互通信 |                          TCP 连接只能是一对一通信                          |
|   面向报文，对用应用层交付的报文直接打包   |                  面向字节流，把数据看成一串无结构的字节流                  |
|                   不可靠                   | 可靠传输，使用流量控制和拥塞控制，传输的数据不会丢失，没有重复，按顺序到达 |
|           首部开销小，仅 8 字节            |                       首部最小 20 字节，最大 60 字节                       |
|    适用于实时应用（IP 电话、视频会议）     |                                  文件传输                                  |

### 面向报文

UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。

具体来说

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

### 不可靠性

1. UDP 是无连接的，也就是说通信不需要建立和断开连接。
2. UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的
3. UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。

### 高效

因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。

![](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-42633.png)

头部包含了以下几个数据

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误

### 传输方式

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

## **DNS**

DNS(Domaim Name System)服务是和 HTTP 协议一样位于应用层的协议。DNS 协议通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。

主要用于 UDP，但是当请求字节过长超过 512 字节时用 TCP 协议，将其分割成多个片段传输。

DNS 协议默认端口号是 53。

操作系统的 DNS 缓存：windows DNS 缓存的默认值是 MaxCacheTTL，它的默认值是 86400s，也就是一天。macOS 严格遵循 DNS 协议中的 TTL。
游览器的 DNS 缓存：chrome 对每个域名会默认缓存 60s；IE 将 DNS 缓存 30min；Firefox 默认缓存时间只有 1 分钟；Safari 约为 10S。
