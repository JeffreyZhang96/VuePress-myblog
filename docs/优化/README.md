[Web 性能|MDN](https://developer.mozilla.org/zh-CN/docs/Web/Performance)

## **减少请求数量**

### 合并文件

不进行文件合并隐患

- 文件与文件之间有插入的上行请求，增加了 N-1 个网络延迟

- 受丢包问题影响更严重

- 经过代理服务器时可能会被断开

文件合并本身也有问题

- 首屏渲染问题

- 缓存失效问题

解决办法

- 公共库合并

- 不同页面单独合并

### 图片处理

#### 雪碧图

CSS 雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的 HTTP 请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG 图片的流行，该技术渐渐退出了历史舞台

#### Base64

将图片的内容以 Base64 格式内嵌到 HTML 中，可以减少 HTTP 请求数量。但是，由于 Base64 编码用 8 位字符表示信息中的 6 个位，所以编码后大小大约比原始值扩大了 33%

#### 字体图标

### 减少重定向

尽量避免使用重定向，当页面发生了重定向，就会延迟整个 HTML 文档的传输。在 HTML 文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验

如果一定要使用重定向，如 http 重定向到 https，要使用 301 永久重定向，而不是 302 临时重定向。因为，如果使用 302，则每一次访问 http，都会被重定向到 https 的页面。而永久重定向，在第一次从 http 重定向到 https 之后 ，每次访问 http，会直接返回 https 的页面

### 使用缓存

使用 cach-control 或 expires 这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用 last-modified 或 etag 这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回 304 响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回 200 响应

### CSS

不使用 CSS @import ,CSS 的@import 会造成额外的请求

### 其它

避免使用空的 src 和 href

- a 标签设置空的 href，会重定向到当前的页面地址

- form 设置空的 method，会提交表单到当前的页面地址

## **减小资源大小**

### 压缩

#### HTML 压缩

HTML 代码压缩就是压缩在文本文件中有意义，但是在 HTML 中不显示的字符，包括空格，制表符，换行符等

#### CSS 压缩

CSS 压缩包括无效代码删除与 CSS 语义合并

#### JS 压缩与混乱

JS 压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护

#### 图片压缩

针对真实图片情况，舍弃一些相对无关紧要的色彩信息

### webp

在安卓下可以使用 webp 格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比 jpg、png 少了 25%以上，而且同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性

### gzip

HTTP 协议上的 GZIP 编码是一种用来改进 WEB 应用程序性能的技术。大流量的 WEB 站点常常使用 GZIP 压缩技术来让用户感受更快的速度。这一般是指 WWW 服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的 40%

## **优化网络连接**

### CDN

CDN 全称是 Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度

静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名，实现分流。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。

CDN 是一台加速服务器，带宽很大，其次他会对文件做缓存，加速服务器都会对文件设置 `cache-control:max-age=86400`,

### DNS 预解析

当浏览器访问一个域名的时候，需要解析一次 DNS，获得对应域名的 ip 地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS 缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到 IP 地址

DNS Prefetch，即 DNS 预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短 DNS 解析时间，来提高网站的访问速度

方法是在 head 标签里面写上几个 link 标签

```html
<link rel="dns-prefecth" href="https://www.google.com" />
<link rel="dns-prefecth" href="https://www.google-analytics.com" />
```

对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间

### 并行连接

由于在 HTTP1.1 协议下，chrome 每个域名的最大并发数是 6 个。使用多个域名，可以增加并发数

### 持久连接

使用 keep-alive 或 presistent 来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量

### 管道化连接

在 HTTP2 协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了

## **资源加载优化**

### 资源加载位置

通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用

1、CSS 文件放在 head 中，先外链，后本页

2、JS 文件放在 body 底部，先外链，后本页

3、处理页面、处理页面布局的 JS 文件放在 head 中，如 babel-polyfill.js 文件、flexible.js 文件

4、body 中间尽量不写 style 标签和 script 标签

构建 Render 树需要 DOM 和 CSSOM，所以 HTML 和 CSS 都会阻塞渲染。所以需要让 CSS 尽早加载（如：放在头部），以缩短首次渲染的时间。

除此之外，由于 CSS 不会阻塞文档的解析，但是会阻塞文档渲染。把 CSS 放在头部可以先生成 CSSOM 树，后续渲染 DOM 的时候，可以一次性构建 Render 树，只需要渲染一次；如果把 CSS 放在后面，会先解析一次 DOM，加载 CSS 之后，会重新渲染之前的 DOM，需要两次渲染。

阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析 HTML。

普通的脚本会阻塞浏览器解析，加上 defer 或 async 属性，脚本就变成异步，可等到解析完毕再执行

async 异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload 前，但不确定在 DOMContentLoaded 事件的前后
defer 延迟执行，相当于放在 body 最后（理论上在 DOMContentLoaded 事件前）

执行 js 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑用 Web Worker,它可以让我们另开一个线程执行脚本，不影响渲染

### 资源加载时机

![](/资源加载优先级.jpg)

#### defer async

1. 脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。

2. defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 HTML 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。

3. async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞 HTML 的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。

#### 模块按需加载

在 SPA 等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块

按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载

webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure

#### 懒加载

懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，
提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。

懒加载实现原理：先将 img 标签的 src 链接设为同一张图片（比如空白图片），然后给 img 标签设置自定义属性（比如 data-src）,然后将真正的图片地址存储在 data-src 中，当 JS 监听到该图片元素进入可视窗口时，将自定义属性中的地址存储到 src 属性中。达到懒加载的效果。

![](/图片懒加载实现原理.jpg)

`offsetTop-scrollTop<clientHeight`，则图片进入了可视区内，则被请求

#### 预加载 preload

[用 preload 预加载页面资源](https://juejin.im/post/5a7fb09bf265da4e8e785c38)

预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时
间，提高用户的体验。

```html
<link rel="preload" href="http://example.com" />
```

预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。

#### 预读取 prefetch

prefetch 告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度

#### 预渲染 prerender

可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染

```html
<link rel="prerender" href="http://example.com" />
```

预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染

## **渲染过程优化**

### 重绘

[从浏览器渲染原理，浅谈回流重绘与性能优化](https://www.cnblogs.com/xiahj/p/11777786.html)

- 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘

- 回流：当渲染树中的元素的布局（如：尺寸、位置、显示隐藏）发生改变时，产生回流

重绘的产生：

1. color,background-color
2. visibility
3. outline

### 回流（重排）

当渲染树中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流

- 回流必将引起重绘，而重绘不一定会引起回流

- 回流会导致渲染树需要重新计算，开销比重绘大，要尽量避免回流的产生

#### 产生

1. 页面首次渲染
2. 浏览器窗口尺寸
3. 元素的位置和尺寸
4. 字体大小
5. 元素内容（文字数量或者图片大小）
6. 激活 CSS 伪类，比如 :hover
7. JS 添加删除可见的 DOM 元素
8. 计算属性
   - `offsetTop`、`offsetLeft`、`offsetWidth`、`offsetHeight`
   - `scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`
   - `clientTop`、`clientLeft`、`clientWidth`、`clientHeight`
   - `scrollIntoView()`、`scrollIntoViewIfNeeded()`
   - `width`、`height`
   - `getComputedStyle()`
   - `getBoundingClientRect()`
   - `scrollTo()`

### 重绘/回流避免方法

#### CSS

- 使用 `transform` 替代 `top`

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）

- 避免使用`table`布局，可能很小的一个小改动会造成整个 `table` 的重新布局。

- 尽可能在`DOM`树的最末端改变`class`，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。

- 避免设置多层内联样式，css 选择符从右往左匹配查找，避免节点层级过多,保证层级扁平。

- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 `requestAnimationFrame`。

- 避免使用`CSS`表达式，可能会引发回流。

- CSS3 硬件加速可以让`transform`、`opacity`、`filters`这些动画不会引起回流重绘 。但是对于动画的其它属性，比如`background-color`这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

#### JS

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。

- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。

- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。

- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

### 样式设置

1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高 CSS 渲染效率

2、避免使用 CSS 表达式，CSS 表达式是动态设置 CSS 属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次

3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流

4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从 0 到完全出现，上下左右都可能位移，发生回流

5、不要使用 table 布局，因为一个小改动可能会造成整个 table 重新布局。而且 table 渲染通常要 3 倍于同等元素时间

6、能够使用 CSS 实现的效果，尽量使用 CSS 而不使用 JS 实现

### 渲染层

1、此外，将需要多次重绘的元素独立为 render layer 渲染层，如设置 absolute，可以减少重绘范围

2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流

### DOM 优化

1、缓存 DOM

const div = document.getElementById('div')
　　由于查询 DOM 比较耗时，在同一个节点无需多次查询的情况下，可以缓存 DOM

2、减少 DOM 深度及 DOM 数量

HTML 中标签元素越多，标签的层级越深，浏览器解析 DOM 并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。

3、批量操作 DOM

由于 DOM 操作比较耗时，且可能会造成回流，因此要避免频繁操作 DOM，可以批量操作 DOM，先用字符串拼接完毕，再用 innerHTML 更新 DOM

4、批量操作 CSS 样式

通过切换 class 或者使用元素的 style.csstext 属性去批量操作元素样式

5、在内存中操作 DOM

使用 DocumentFragment 对象，让 DOM 操作发生在内存中，而不是页面上

6、DOM 元素离线更新

对 DOM 进行相关操作时，例、appendChild 等都可以使用 Document Fragment 对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用 display:none 对元素隐藏，在元素“消失”后进行相关操作

7、DOM 读写分离

浏览器具有惰性渲染机制，连接多次修改 DOM 可能只触发浏览器的一次渲染。而如果修改 DOM 后，立即读取 DOM。为了保证读取到正确的 DOM 值，会触发浏览器的一次渲染。因此，修改 DOM 的操作要与访问 DOM 分开进行

8、事件代理

事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件

利用事件代理，可以减少内存使用，提高性能及降低代码复杂度

9、及时清理环境

及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存

### 防抖

一个频繁触发的函数，在规定时间内，只让最后一次生效

```js
function debounce(f, wait) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      f(...args);
    }, wait);
  };
}

var input = document.getElementById('input');
input.addEventListener(
  'keyup',
  debounce(function() {
    //用普通函数可以用this.value，arguments可以用于获取集体按下键
    console.log(input.value);
    console.log(this);
    console.log(arguments);
  }, 1000)
);
```

应用场景：

- 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖
- 搜索联想，用户在不断输入值时，用防抖来节约请求资源
- window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
- 文本编辑器实时保存，当无任何更改操作一秒后进行保存

### 节流

一个函数执行一次后，只有大于设定的执行周期后才会执行第二次

```js
function throttle(f, wait) {
  let timer;
  return (...args) => {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      f(...args);
      timer = null;
    }, wait);
  };
}

div.addEventLisener(
  'keyup',
  throttle(function(e) {
    //e=>arguments
    console.log(e.offsetX, e.offsetY);
  })
);
```

应用场景：

- scroll 事件，每隔一秒计算一次位置信息等
- 浏览器播放事件，每个一秒计算一次进度信息等

## **性能更好的 API**

### 选择器

选择器的性能排序如下所示，尽量选择性能更好的选择器

复制代码
id 选择器（#myid）
类选择器（.myclassname）
标签选择器（div,h1,p）
相邻选择器（h1+p）
子选择器（ul > li）
后代选择器（li a）
通配符选择器（\*）
属性选择器（a[rel="external"]）
伪类选择器（a:hover,li:nth-child）
复制代码

### 使用 requestAnimationFrame 来替代 setTimeout 和 setInterval

希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧

### 使用 IntersectionObserver 来实现图片可视区域的懒加载

传统的做法中，需要使用 scroll 事件，并调用 getBoundingClientRect 方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用 IntersectionObserver，则没有上述问题

### web worker

客户端 javascript 一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker 是 HTML5 提供的一个 javascript 多线程解决方案，可以将一些大计算量的代码交由 web Worker 运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个 API 非常有用

但是，使用一些新的 API 的同时，也要注意其浏览器兼容性

## **首屏优化方法总结**

1. 渲染优化

- CCSS 放在 header，js 放在 body 尾部，不阻塞渲染
- defer async 资源懒加载
- 图片懒加载，视频或音频禁止自动播放

2. 网络优化

- 减少 HTTP 请求
- 合并资源文件（CSS, JS, 雪碧图）
- webpack 打包压缩资源文件（tree shaking gzip）
- 后端开启 gzip 静态文件压缩
- 合理设置 HTTP 缓存
- dns 预解析，CDN 缓存增加并发数
- 代码分割，路由懒加载[四年前端带你理解路由懒加载的原理](https://segmentfault.com/a/1190000022846552)

## **白屏优化**

[首页白屏优化实践](https://juejin.im/post/6844903941713428487)

[首屏时间(FCP) VS 白屏时间(FP)](https://juejin.im/post/6844904112107044872)

[前端性能监控方案（首屏、白屏时间等）](https://juejin.im/post/6844904020482457613)
